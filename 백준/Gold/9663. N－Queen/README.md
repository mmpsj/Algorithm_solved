# [Gold IV] N-Queen - 9663 

[문제 링크](https://www.acmicpc.net/problem/9663) 

### 성능 요약

메모리: 14468 KB, 시간: 4716 ms

### 분류

백트래킹, 브루트포스 알고리즘

### 제출 일자

2024년 4월 17일 22:19:01

### 문제 설명

<p>N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.</p>

<p>N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 N이 주어진다. (1 ≤ N < 15)</p>

### 출력 

 <p>첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.</p>

### 풀이

각 n에 대한 경우의 수는 [여기](https://oeis.org/A000170)에서 확인할 수 있다. (n == 0부터 시작)

처음에 문제를 마주했을 때는, 실버의 N과 M문제들처럼 방문한 노드를 체크하고, 하위 노드로 내려가고, 이미 방문한 곳이면 되돌아가는 방식으로 구현하려 했다. 

그래서 이 문제에서 노드는 체스판의 각 칸이라고 생각하고, 배열로 만들어서 사용하려고 했다. N과 M 문제들처럼 재귀 함수에서 해당 칸이 false일 때 들어가서 true로 바꾸고, 다음 재귀 호출하고, 이런 식으로 반복하려 했다. 이때 각 칸을 true로 바꾸는 것뿐 아니라 같은 행, 열, 대각선까지 true로 바꿔야 하므로 8방향 각각 경우를 나누어 반복문으로 끝까지 true로 바꾸게 했다. 

true로 바꿀 때는 문제가 없었는데, 재귀 호출이 끝나고 다시 false로 바꿀 때 문제가 생겼다. 내 퀸에 해당하는 공격 범위를 해제할 때, 나보다 먼저 놓인 퀸의 공격 범위도 해제될 수 있다는 것이다. 그래서 이 문제를 해결하려면 내 퀸의 공격 범위로 true로 바뀐 칸들을 기록하는 것이 필요했다. 이렇게 하려고 하니, 구조가 점점 복잡해지고, 저장할 데이터도 많아지고, 코드가 지저분해져서 다시 처음부터 시작하기로 했다.

먼저 백트래킹에 대한 개념을 제대로 이해하지 않고 무작정 문제를 풀려고 했던 것이어서, 간단하게 유튜브에 있는 [강의](https://www.youtube.com/watch?v=HRwFgtiqHH0)를 봤다.

앞의 N과 M 문제를 풀면서 그저 모든 경우를 확인하는 알고리즘이라고 생각했는데, 생각해보니 이는 브루트 포스 알고리즘이었다. 

백트래킹 알고리즘은 그와 달리 어떤 상태 공간에서 유망하지 않은 노드들은 가지치기하면서 경우의 수를 줄이고, 해답인 원소의 순서를 찾아가는 알고리즘이다. 이때 유망 함수를 찾는 것이 중요하고 어렵다.

이 문제에서 상태 공간은 체스의 각 칸이다. 문제를 풀기 위해 먼저 상태 공간을 줄이는 것이 좋다. 그래서 퀸이 놓인 행은 다른 퀸이 놓일 수 없다는 기본 가정을 깔고 시작했다. 이렇게 하면 총 경우의 수는 각 행에 퀸이 놓이는 경우의 수인 n을 n번 곱한 값이다.(n^n)

이렇게 되면 내가 다뤄야 할 자료구조는 각 행에서 몇번째 열에 퀸이 들어갈지를 저장하는 크기 n의 int형 배열이다. 이 배열의 인덱스는 현재 퀸을 배치하려는 행, 배열의 값은 해당 행의 퀸이 들어갈 열을 나타낸다. 이렇게 배열을 사용하면, 각 퀸의 공격 범위도 판단할 수 있게 된다. 행은 기본 가정으로 배제돼있고, 열은 배열 내에 같은 값을 가지지 않도록 하면 된다. 대각선은 인덱스끼리의 차와 배열값의 차가 같으면 대각선에 해당하는 것이다. 이 조건을 유망 함수에 사용하면 된다.

재귀 함수의 인자로는 depth를 판별하면서, 현재 퀸을 배치하려는 행의 인덱스를 알려준다. 즉 맨 위 행부터 아래로 내려가면서 배치하면 depth와 행 동시에 확인할 수 있다. 

```java
public static void dfs(int i)
```

재귀 함수에서는 먼저 종료 조건을 확인한다. i가 n과 같으면 해답을 1개 찾은 것으로, 결과를 1개 더하고 종료한다. 이후 반복문을 n번 돌려서, 현재 행의 열을 선택한다. 이때 유망 함수를 통해 해당 열에 들어갈 수 있는지 확인하고, 들어갈 수 없으면 다음 열로 넘어간다. 들어갈 수 있다면 재귀 호출하여 진행한다.

```java
public static void dfs(int i) {
    if (i == n) {
        result++;
        return;
    }
    for (int j = 0; j < n; j++) {
        arr[i] = j;
        if (!promising(i)) continue;
            dfs(i + 1);
    }
}
```

유망 함수의 인자로는 현재 퀸을 배치하려는 행의 인덱스를 준다.

```java
public static boolean promising(int i)
```

유망 함수 내에서는 i - 1만큼 반복문을 돌리는데, 배열의 인덱스가 i보다 작은 값들과 i를 비교하는 것이다. 이때 비교는 위에서 말했듯 배열의 값으로 열을 확인하고, 인덱스의 차와 배열값의 차가 같으면 대각을 확인하는 것이다.

```java
if (arr[i] == arr[j] || Math.abs(arr[i] - arr[j]) == i - j)
```

여기서 오른쪽의 비교는, i는 항상 j보다 크기 때문에 우변은 항상 양수이다. 좌변에 절댓값을 취하는 이유는 왼쪽 대각선일지 오른쪽 대각선일지 모르기 때문이다. 이 조건을 만족할 때는 false를 반환하고 아니라면 true를 반환하면 된다.

백트래킹에 대한 명확한 이해를 하지 않고 문제를 풀려고 하니 풀이가 굉장히 조잡해졌었다. 앞으로 문제를 풀 때는 개념을 이해하고, 조건을 잘 확인하면서 상태 공간을 줄이는 방향을 먼저 고려해야할 것 같다.
