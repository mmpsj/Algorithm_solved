# [Gold V] 하노이 탑 이동 순서 - 11729 

[문제 링크](https://www.acmicpc.net/problem/11729) 

### 성능 요약

메모리: 44000 KB, 시간: 536 ms

### 분류

재귀

### 제출 일자

2024년 4월 16일 22:12:20

### 문제 설명

<p>세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.</p>

<ol>
	<li>한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.</li>
	<li>쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.</li>
</ol>

<p>이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라. 단, 이동 횟수는 최소가 되어야 한다.</p>

<p>아래 그림은 원판이 5개인 경우의 예시이다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11729/hanoi.png" style="height:200px; width:1050px"></p>

### 입력 

 <p>첫째 줄에 첫 번째 장대에 쌓인 원판의 개수 N (1 ≤ N ≤ 20)이 주어진다.</p>

### 출력 

 <p>첫째 줄에 옮긴 횟수 K를 출력한다.</p>

<p>두 번째 줄부터 수행 과정을 출력한다. 두 번째 줄부터 K개의 줄에 걸쳐 두 정수 A B를 빈칸을 사이에 두고 출력하는데, 이는 A번째 탑의 가장 위에 있는 원판을 B번째 탑의 가장 위로 옮긴다는 뜻이다.</p>

### 풀이

우선 재귀로 푸는 문제의 특성 상 n이 낮은 경우를 연상하다 보면 풀리는 경우가 많다.

먼저 n == 1인 경우, 1에서 3으로 1번 옮기면 끝난다. 

n == 2인 경우, n == 1인 경우에 블럭이 하나 추가됐으므로, 그를 옮기는 과정이 필요하다. 1번 블럭을 2에 옮기고, 2번 블럭을 3에 옮기고, 1번 블럭을 3에 옮기면 끝난다. 총 3번 움직인다.

n == 3인 경우, 마찬가지로 n == 2인 경우에 블럭이 하나 추가됐으므로, 1, 2번 블럭을 2에 옮기고, 3번 블럭을 3에 옮기고, 1, 2번 블럭을 3에 옮기면 된다. 즉 n == 2일 때의 작업을 하고, 한개 옮기고, 다시 n == 2일 때의 작업을 하면 되는 것이다.

즉, 총 옮기는 횟수는 n - 1 단계의 횟수 * 2 + 1이 된다. n == 1 -> 1, n == 2 -> 3, n == 3 -> 7, ... 다르게 표현하면 2^n - 1이다. 

총 옮기는 횟수는 완료됐고, 이제 각 단계를 확인하면 된다.

위에서 말했듯 n - 1단계를 진행하고, 블럭 1개 옮기고, 다시 n - 1단계를 진행하게 된다.

함수의 인자로는 출력문을 받을 StringBuilder 객체, 각 단계 n, 현재 단계의 시작 칸, 다른 칸, 도착 칸 세 가지를 받았다. 다른 칸을 받는 이유는, 현재 단계에서 가장 큰 블럭을 제외하고 그 위 블럭들을 그 칸에 옮겨놨다가 가장 큰 블럭을 도착 칸에 옮기고, 옮겨놓은 블럭들을 도착 칸에 옮겨야 하기 때문이다. 각 칸에 대한 인자는 int로 해도 되지만, 단순히 구분만 하는 용도이므로 char로 선언했다.

```java
public static void hanoi(StringBuilder sb, int n, char from, char temp, char to)
```

함수 안에서는 먼저 n == 1인지 확인하여 해당 경우 작업을 한다. sb에 from + ' ' + to + '\n'을 추가하고 종료하면 된다.

n이 1이 아니라면 위에서 설명한 과정을 진행한다.

먼저 n-1만큼을 다른 칸에 옮긴다.

```java
hanoi(sb, n - 1, from, to, temp);
```

이후 가장 큰 블럭을 옮기는 결과를 sb에 추가한다.

```java
sb.append(from).append(' ').append(to).append('\n');
```

마지막으로 다른 칸에 있던 n-1만큼을 도착 칸에 옮긴다.

```java
hanoi(sb, n - 1, temp, from, to);
```

재귀적으로 진행되기 때문에 디테일한 진행 사항은 결과가 알려줄 것이고, 함수 호출만 하면 된다. 재귀로 푸는 문제의 특징이다!
